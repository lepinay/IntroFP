On OOP
Encapsulation
Inheritance
Polymorphism

Alan kay
OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things
I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” … The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be

On mutability
http://pivotallabs.com/all-evidence-points-to-oop-being-bullshit/
State is not your friend, state is your enemy. Changes to state make programs harder to reason about, harder to test and harder to debug. Stateful programs are harder to parallelize, and this is important in a world moving towards more units, more cores and more work. OOP languages encourage mutability, non determinism and complexity.
As someone who was initially hostile to the idea that state is the root of all problems, I initially greeted this idea with skepticism. Mutating state is so easy and fundamental in OOP that you often overlook how often it happens. If you’re invoking a method on an object that’s not a getter, you’re probably mutating state.
...
OOP programs that exhibit low coupling, cohesion and good reusability sometimes feel like nebulous constellations, with hundreds of tiny objects all interacting with each other. Sacrificing readability for changeability. Many of OOP best practices are in fact encouraged by functional programming languages.

http://whiley.org/2010/06/23/rich-hickey-on-clojure-se-radio/
Even if you don’t have concurrency, I think that large objected-oriented programs struggle with increasing complexity as you build this large object graph of mutable objects. You know, trying to understand and keep in your mind what will happen when you call a method and what will the side-effects be.

http://harmful.cat-v.org/software/OO_programming/why_oo_sucks
Since functions and data structures are completely different types of animal it is fundamentally incorrect to lock them up in the same cage.


Strong Ideas on FP
Michael Feathers (Working Effectively with Legacy Code): OO makes code understandable by encapsulating moving parts.  FP makes code understandable by minimizing moving parts.

001 Hello World
C#:Already more clutter
F#:This actually compiles and runs like that

002 Basic Types
C#: You can specify types or use type inference too.
F#: No types needed; No semi colons

003 Lists
C#: oneToFive need to be a new list, using Linq is cheating here
F#: 
	Square brackets create a list with
	:: (cons) creates list with new 1st element
	@ concats two lists

004 Functions
C#: 
	Functions must live in a class
	OOP adds unecessary cluter
F#: 
	Function are *First Class* (declared as variables, passed around)
	No Parens for delcaring and running

005 Functions
F#: Notice we don't use (2,3) this mean someting else 

006: We discover that Linq is FP
C#: 
	This is the implementation Pre-Linq
	Linq introduced FP concepts into C#
	C# new features are often inspired by F#: Linq, Async, Tuples, Primary constructors
	*ENCAPSULATION* is done using private class methods
F#: 
	This is the basic way of doing in it (similar to Linq)
	*ENCAPSULATION* is done using nested functions
		Remember the recently discovered "Module" pattern in javascript ? (requirejs)

007: If Then Else
C#: 
F#:
	No return statement, in F# everything is an expression that must evaluate to something.	
	Since we use pure function a LOT writing "return" would be cumbersome
	returning value is the norm

008: Piping
C#:
	This is a really imperative version
		You need to deal with the i counter
		You need to deal with the update of sum
		The logic of what we are trying to achieve is mixed with book keeping
F#: 
	|> is called the pipe "operator" (similar to unix pipes)
	Get rid of all side effects => more concise code
		No curlies, no semi colons
	We can see the data flow
	*TYPE INFERENCE*: 
		No type declaration
		F# type inference > C#: No need in function decl and lambdas (Func,Action)

	Notice how the function is on one line (In C# it would be bad!)

009: Sorting (Non optimized)
If the list is empty, there is nothing to do.
Otherwise: 
  1. Take the first element of the list
  2. Find all elements in the rest of the list that 
      are less than the first element, and sort them. 
  3. Find all elements in the rest of the list that 
      are >= than the first element, and sort them
  4. Combine the three parts together to get the final result: 
      (sorted smaller elements + firstElement + 
       sorted larger elements)
C#:
	Lots of noise (Algorithm is lost in details)
	Version really imperative (How to do it)
F#:
	No Types, will work on all lists
	rec for recursive
	*PATTERN MATCHING* (Go trought the code)
	This version match the algorithm, more declarative (what to do)

	Less Bugs thanks to Pattern Matching
	Pattern matching forces us to handle the empty list case

010: Web page download
C#: 
	Really noisy, notice all the Func stuff
	all using on top (Old c style)
	Generics add noise, notice TResult
F#:
	We specify Create(Uri) to help the compiler with overrides
	Notice we don't write new Uri, just Uri'
	we use 'use' for disposable resources, more readable than c#
	Again no type declaration => less noise, to the point

011: Web Page Download (usage)
C#:
F#:
	Currying
	First class string interpolation
	

XXX FizzBuzz
The "Fizz-Buzz test" is an interview question designed to help filter out the 99.5% of programming job candidates who can't seem to program their way out of a wet paper bag. The text of the programming assignment is as follows:
"Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”."


XXX: DataScience
	1. Acquire Data (F# Data providers FTW)
	2. Explore
	3. Analyse and loop

FP 
	Like spreadsheets
		Each cells contains formulas that depend on other cells
		Cells do not contain things like "print blab la"
		Cells are pure

	Variables
		In imperative language they are location, "x" can change wherever in scope
		In FP they are constant values, "x" is the same forever wherever in scope

	First class function / High Order functions
		Functions as parameters (Ex filters, predicates)
		Functions as return values (Ex Factories)

	Side effects
		Calling a function that does other than returning a result
		
		Why no side effect is good
			Easier to understand
				Just look at the interface: you can see in and out, no hidden dependencies like global state
			Easier to test
				No setup state of the world
				No mocks
				No test like "if shouldnt change that"
			Easier for parallel code
				No worries about locking

	POO: Easy to add new DataTypes, Hard To add New Behaviour (You have to go over all your types and implement)
	FP: Easy to add new behaviour on Types, Hard to add new Types (Have to create new functions )