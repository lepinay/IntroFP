Introduction example
let a = 1
a = 2
a ?

Objective
We want to
	Deliver faster
	Deliver correct software

Solution
	Raise our level of abstraction
	ASM -> C -> GC Languages -> FP

About the introduction
	Examples in C#/F#
	General principles
	C/C++/Java/Scala/Clojure

OOP
	We build programs using Objects
	We use imperative Statements (Change this, change that)

FP
	It's a style of programming'
	We build programs using functions expressions
	Expressions return values
	We use composition
	It's like building a tree (functions that call functions that call functions)
Vs Imperative
	We use statements
	Programs are built by changing a global state

FP History
	1930s Lambda Calculus, "Programming" using Math
	1950s Lisp, first FPL influenced by Lambda Calculus with assignment
	1960s If You See What I Mean, Real implementation of Lambda Calculus (no assigment)
	1970s Fortran, imperative with high order functions
	1970s ML, hybrid, PURE FP with assignment, type inference, proof oriented, generics (List<T>)
	1970-80, David Turner, Lazy Languages
	1987, Haskell

On OOP
Encapsulation
Inheritance
Polymorphism

Alan kay
OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things
I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” … The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be

On mutability
http://pivotallabs.com/all-evidence-points-to-oop-being-bullshit/
State is not your friend, state is your enemy. Changes to state make programs harder to reason about, harder to test and harder to debug. Stateful programs are harder to parallelize, and this is important in a world moving towards more units, more cores and more work. OOP languages encourage mutability, non determinism and complexity.
As someone who was initially hostile to the idea that state is the root of all problems, I initially greeted this idea with skepticism. Mutating state is so easy and fundamental in OOP that you often overlook how often it happens. If you’re invoking a method on an object that’s not a getter, you’re probably mutating state.
...
OOP programs that exhibit low coupling, cohesion and good reusability sometimes feel like nebulous constellations, with hundreds of tiny objects all interacting with each other. Sacrificing readability for changeability. Many of OOP best practices are in fact encouraged by functional programming languages.

http://whiley.org/2010/06/23/rich-hickey-on-clojure-se-radio/
Even if you don’t have concurrency, I think that large objected-oriented programs struggle with increasing complexity as you build this large object graph of mutable objects. You know, trying to understand and keep in your mind what will happen when you call a method and what will the side-effects be.

http://harmful.cat-v.org/software/OO_programming/why_oo_sucks
Since functions and data structures are completely different types of animal it is fundamentally incorrect to lock them up in the same cage.


Strong Ideas on FP
Michael Feathers (Working Effectively with Legacy Code): OO makes code understandable by encapsulating moving parts.  FP makes code understandable by minimizing moving parts.

Advantages of immuability
	You don't need to unit test for certain kind of bug
		Who never write unit test to check that a function does not do some side effects
		Some people say (gave up)you should only test for what the function should do not what it shouldn't do
		Why not then use a language that enforce this and not REALLY worry about it

		

001 Hello World
C#:Already more clutter
F#:This actually compiles and runs like that

002 Basic Types
C#: You can specify types or use type inference too.
F#: No types needed; No semi colons

003 Lists
C#: oneToFive need to be a new list, using Linq is cheating here
F#: 
	Square brackets create a list with
	:: (cons) creates list with new 1st element
	@ concats two lists

004 Functions
C#: 
	Functions must live in a class
	OOP adds unecessary cluter
F#: 
	Function are *First Class* (declared as variables, passed around)
	No Parens for delcaring and running

005 Functions
F#: Notice we don't use (2,3) this mean someting else 

006: We discover that Linq is FP
C#: 
	This is the implementation Pre-Linq
	Linq introduced FP concepts into C#
	C# new features are often inspired by F#: Linq, Async, Tuples, Primary constructors
	*ENCAPSULATION* is done using private class methods
F#: 
	This is the basic way of doing in it (similar to Linq)
	*ENCAPSULATION* is done using nested functions
		Remember the recently discovered "Module" pattern in javascript ? (requirejs)

007: If Then Else
C#: 
F#:
	No return statement, in F# everything is an expression that must evaluate to something.	
	Since we use pure function a LOT writing "return" would be cumbersome
	returning value is the norm

008: Statements versus Expressions
C#: 
	In an imperative language, we mess around with state to get things done
	This can lead to bugs
	This lead to more complexity
	We chain these to achieve BBOM ?
F#:
	In FP we don't mess around with state
	We use expressions
	Expression take inputs and return outputs
	We chain theses to achieve pure work

008: Piping
C#:
	This is a really imperative version
		You need to deal with the i counter
		You need to deal with the update of sum
		The logic of what we are trying to achieve is mixed with book keeping
F#: 
	|> is called the pipe "operator" (similar to unix pipes)
	Get rid of all side effects => more concise code
		No curlies, no semi colons
	We can see the data flow
	*TYPE INFERENCE*: 
		No type declaration
		F# type inference > C#: No need in function decl and lambdas (Func,Action)

	Notice how the function is on one line (In C# it would be bad!)

009: Sorting (Non optimized)
If the list is empty, there is nothing to do.
Otherwise: 
  1. Take the first element of the list
  2. Find all elements in the rest of the list that 
      are less than the first element, and sort them. 
  3. Find all elements in the rest of the list that 
      are >= than the first element, and sort them
  4. Combine the three parts together to get the final result: 
      (sorted smaller elements + firstElement + 
       sorted larger elements)
C#:
	Lots of noise (Algorithm is lost in details)
	Version really imperative (How to do it)
F#:
	No Types, will work on all lists
	rec for recursive
	*PATTERN MATCHING* (Go trought the code)
	This version match the algorithm, more declarative (what to do)

	Less Bugs thanks to Pattern Matching
	Pattern matching forces us to handle the empty list case

010: Web page download
C#: 
	Really noisy, notice all the Func stuff
	all using on top (Old c style)
	Generics add noise, notice TResult
F#:
	We specify Create(Uri) to help the compiler with overrides
	Notice we don't write new Uri, just Uri'
	we use 'use' for disposable resources, more readable than c#
	Again no type declaration => less noise, to the point

011: Web Page Download (usage)
C#:
	No type inference on Func !
	There is a form of repetition in parameters passing (no currying)
F#:
	Type inference on functions
	Currying
	First class string interpolation

012:Types Hierarchies
C#:
	We use polymorphism
	We could use property initializer to simply the class code 
		but the initialisation more complicated and less safe
		I Hate property initializer because the don't guarantee integirty'
	We use constructors with FEAR
		We don't know what could happen to our dependencies because of mutuability
		Our object could enter invalid state
		We need "stupid" defensive coding
	Seriously look at all this useless TYPING
	Notice also how Visal Studio encourages us to write MUTABLE code with get,set
	Normally to be more Entreprisy you would need to split everything in 6 separated files
		Because Classes are code + Data they tend to need their own file
	Easy to plug in a new shape without touching existing code
		Good for plugin architecture
	Hard to add a new behaviour (you have to update all concrete types)
	Behaviour First

F#:
	We use pattern matching
	Fits on the screen (Then can fit in your head)
	You usually don't need several files for your domain'
	Pattern matching ensure you consider everything
		So it's nice for static cases like in your domain'
		Maybe not so nice for dynamic cases like in a plugin architecture
	Easy to add a new behaviour without touching existing code (just implement a new function with all cases)
		Good for correctness, the compiler will tell what need to be updated
	Hard to add a new Shape but SAFE (you have to update all the functions that depend on the type Shape)
	Data Domain First
	Component Entity Systems

013: Complex Types
C#: 
	Creation of immutable type is recognized as a good thing
	But it's painfull to do
F#:
	In FP immuability is so impotant that it's the default everywhere
	Creating immutable type is a one liner

014: Pretty printing
C#: 
	lots of boring boiler code
	gets pretty complicated the more your object have field
F#:
	Nothing to do !

015: Equality
C#: This is getting ugly
F#: Surprise nothing to do

016: Comparison
C#: 
	Seriously look at all this boiler code
	How confident are you that this will work ?
	Imagine to do that for dozen of classes 
	No wonder C# dev are not encouraged to write immutable code
	We shouldn't be paid to write that kind of code'
	More importantly we are loosing forest for the trees
	I remeber feeling smart when I used to write that kind of code
F#:
	Nothing to do, fields are compared structuraly in order

017: Decorator Design Pattern
Design Pattern: 
"general reusable solution to a commonly occurring problem within a given context in software design" - Wikipedia
 Peter Norvig demonstrates that 16 out of the 23 patterns in the Design Patterns book (that is primarily focused on C++) are simplified or eliminated (via direct language support) in Lisp
 C#:
	A basic calculator
	We want to add loging so we wrap the calculator using the Decorator Pattern
F#:
	Because functions are first class
	we can pass them as parameters
	Composition is clean and easy
	Notice that our logger can be reused in place of calculator (same interface)

01-019: Generic logger + Generic Timer with logging
F#:
	Actually any funcition that math the "inteface" can be passed
	so we can have a generic logger on any thing that is a'->b'
	This really help in creativity and composition
	We have far better composibility since we don't really depend on an static interface
C#: 
	We can do the same in term of composition of adapters but we are stuck with ICalculator
	The only way to do that in C# is using a functional style (delegate)



XXX Active Patterns



	

XXX FizzBuzz
The "Fizz-Buzz test" is an interview question designed to help filter out the 99.5% of programming job candidates who can't seem to program their way out of a wet paper bag. The text of the programming assignment is as follows:
"Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”."


XXX: DataScience
	1. Acquire Data (F# Data providers FTW)
	2. Explore
	3. Analyse and loop

FP 
	Like spreadsheets
		Each cells contains formulas that depend on other cells
		Cells do not contain things like "print blab la"
		Cells are pure

	Variables
		In imperative language they are location, "x" can change wherever in scope
		In FP they are constant values, "x" is the same forever wherever in scope

	First class function / High Order functions
		Functions as parameters (Ex filters, predicates)
		Functions as return values (Ex Factories)

	Side effects
		Calling a function that does other than returning a result
		
		Why no side effect is good
			Easier to understand
				Just look at the interface: you can see in and out, no hidden dependencies like global state
			Easier to test
				No setup state of the world
				No mocks
				No test like "if shouldnt change that"
			Easier for parallel code
				No worries about locking

	POO: Easy to add new DataTypes, Hard To add New Behaviour (You have to go over all your types and implement)
	FP: Easy to add new behaviour on Types, Hard to add new Types (Have to create new functions )